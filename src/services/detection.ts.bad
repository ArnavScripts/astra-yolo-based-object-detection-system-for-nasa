import { projectId, publicAnonKey } from "../utils/supabase/info";import { projectId, publicAnonKey } from "../utils/supabase/info";



export interface ModelConfig {export interface ModelConfig {

  modelEndpoint: string;  modelEndpoint: string;

  apiKey: string;  apiKey: string;

  modelType: "custom" | "roboflow" | "huggingface";  modelType: "custom" | "roboflow" | "huggingface";

}}



export interface Detection {export interface Detection {

  className: string;  className: string;

  confidence: number;  confidence: number;

  bbox: {  bbox: {

    x: number;    x: number;

    y: number;    y: number;

    width: number;    width: number;

    height: number;    height: number;

  };  };

}}



async function resolveApiBase(): Promise<{ base: string; authHeader?: string }> {async function resolveApiBase(): Promise<{

  const meta: any = import.meta as any;  base: string;

  const local = meta?.env?.VITE_LOCAL_API || "";  authHeader?: string;

  if (local) return { base: local.replace(/\/+$/, "") };}> {

  const meta: any = import.meta as any;

  try {  const local = meta?.env?.VITE_LOCAL_API || "";

    // Avoid circular reference by importing dynamically  if (local) return { base: local.replace(/\/+$/, "") };

    const { getModelConfig } = await import("./detection");

    const cfg = await getModelConfig();  try {

    if (cfg && cfg.modelEndpoint) {    // Avoid circular reference by importing dynamically

      const header = cfg.apiKey ? `Bearer ${cfg.apiKey}` : undefined;    const { getModelConfig } = await import("./detection");

      return { base: cfg.modelEndpoint.replace(/\/+$/, ""), authHeader: header };    const cfg = await getModelConfig();

    }    if (cfg && cfg.modelEndpoint) {

  } catch (e) {      const header = cfg.apiKey ? `Bearer ${cfg.apiKey}` : undefined;

    // ignore      return {

  }        base: cfg.modelEndpoint.replace(/\/+$/, ""),

        authHeader: header,

  return { base: `https://${projectId}.supabase.co/functions/v1/make-server-ce7e8b87`, authHeader: `Bearer ${publicAnonKey}` };      };

}    }

  } catch (e) {

// Note: keep function order so getModelConfig exists when called normally.    // ignore

export async function getModelConfig(): Promise<ModelConfig | null> {  }

  try {

    // For this call we can use the supabase fallback directly without resolving saved config  return {

    const response = await fetch(`https://${projectId}.supabase.co/functions/v1/make-server-ce7e8b87/model-config`, {    base: `https://${projectId}.supabase.co/functions/v1/make-server-ce7e8b87`,

      headers: { Authorization: `Bearer ${publicAnonKey}` },    authHeader: `Bearer ${publicAnonKey}`,

    });  };

    if (!response.ok) throw new Error("Failed to fetch model config");}

    const data = await response.json();

    return data.config || null;// Note: keep function order so getModelConfig exists when called normally.

  } catch (e) {export async function getModelConfig(): Promise<ModelConfig | null> {

    console.error("getModelConfig error", e);  try {

    return null;    // For this call we can use the supabase fallback directly without resolving saved config

  }    const response = await fetch(

}      `https://${projectId}.supabase.co/functions/v1/make-server-ce7e8b87/model-config`,

      {

export async function listServerPredictions(): Promise<{ success: boolean; predictions: any[] }> {        headers: { Authorization: `Bearer ${publicAnonKey}` },

  try {      }

    const resolved = await resolveApiBase();    );

    const headers: Record<string, string> = {};    if (!response.ok) throw new Error("Failed to fetch model config");

    if (resolved.authHeader) headers["Authorization"] = resolved.authHeader;    const data = await response.json();

    const resp = await fetch(`${resolved.base}/predictions`, { headers });    return data.config || null;

    if (!resp.ok) throw new Error("Failed to list predictions");  } catch (e) {

    return await resp.json();    console.error("getModelConfig error", e);

  } catch (err) {    return null;

    console.error("Error listing server predictions", err);  }

    return { success: false, predictions: [] };}

  }

}export async function listServerPredictions(): Promise<{

  success: boolean;

export async function saveModelConfig(config: ModelConfig): Promise<boolean> {  predictions: any[];

  try {}> {

    const resolved = await resolveApiBase();  try {

    const headers: Record<string, string> = { "Content-Type": "application/json" };    const resolved = await resolveApiBase();

    if (resolved.authHeader) headers["Authorization"] = resolved.authHeader;    const headers: Record<string, string> = {};

    const response = await fetch(`${resolved.base}/model-config`, {    if (resolved.authHeader) headers["Authorization"] = resolved.authHeader;

      method: "POST",    const resp = await fetch(`${resolved.base}/predictions`, { headers });

      headers,    if (!resp.ok) throw new Error("Failed to list predictions");

      body: JSON.stringify(config),    return await resp.json();

    });  } catch (err) {

    return response.ok;    console.error("Error listing server predictions", err);

  } catch (e) {    return { success: false, predictions: [] };

    console.error("saveModelConfig error", e);  }

    return false;}

  }

}export async function saveModelConfig(config: ModelConfig): Promise<boolean> {

  try {

export async function detectObjects(imageData: string): Promise<Detection[]> {    const resolved = await resolveApiBase();

  const resolved = await resolveApiBase();    const headers: Record<string, string> = {

  const headers: Record<string, string> = { "Content-Type": "application/json" };      "Content-Type": "application/json",

  if (resolved.authHeader) headers["Authorization"] = resolved.authHeader;    };

    if (resolved.authHeader) headers["Authorization"] = resolved.authHeader;

  const response = await fetch(`${resolved.base}/detect`, {    const response = await fetch(`${resolved.base}/model-config`, {

    method: "POST",      method: "POST",

    headers,      headers,

    body: JSON.stringify({ imageData }),      body: JSON.stringify(config),

  });    });

    return response.ok;

  if (!response.ok) {  } catch (e) {

    const errData = await response.json().catch(() => ({ error: response.statusText }));    console.error("saveModelConfig error", e);

    throw new Error(errData.error || `Detection failed: ${response.statusText}`);    return false;

  }  }

}

  const data = await response.json();

  if (!data.success) throw new Error(data.error || "Detection failed");export async function detectObjects(imageData: string): Promise<Detection[]> {

  return normalizeDetections(data.detections || []);  const resolved = await resolveApiBase();

}  const headers: Record<string, string> = {

    "Content-Type": "application/json",

export async function detectObjectsBatch(images: string[]): Promise<Detection[][]> {  };

  const resolved = await resolveApiBase();  if (resolved.authHeader) headers["Authorization"] = resolved.authHeader;

  const headers: Record<string, string> = { "Content-Type": "application/json" };

  if (resolved.authHeader) headers["Authorization"] = resolved.authHeader;  const response = await fetch(`${resolved.base}/detect`, {

    method: "POST",

  const response = await fetch(`${resolved.base}/detect-batch`, {    headers,

    method: "POST",    body: JSON.stringify({ imageData }),

    headers,  });

    body: JSON.stringify({ images }),

  });  if (!response.ok) {

    const errData = await response

  if (!response.ok) {      .json()

    const errData = await response.json().catch(() => ({ error: response.statusText }));      .catch(() => ({ error: response.statusText }));

    throw new Error(errData.error || `Batch detection failed: ${response.statusText}`);    throw new Error(

  }      errData.error || `Detection failed: ${response.statusText}`

  const data = await response.json();    );

  if (!data.success) throw new Error(data.error || "Batch detection failed");  }

  return data.results.map((r: any) => (r.success ? normalizeDetections(r.detections || []) : []));

}  const data = await response.json();

  if (!data.success) throw new Error(data.error || "Detection failed");

export async function testModelConnection(): Promise<{ success: boolean; message: string }> {  return normalizeDetections(data.detections || []);

  try {}

    const testImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8DwHwAFBQIAX8jx0gAAAABJRU5ErkJggg==";

    await detectObjects(testImage);export async function detectObjectsBatch(

    return { success: true, message: "Model connection successful!" };  images: string[]

  } catch (e: any) {): Promise<Detection[][]> {

    return { success: false, message: e?.message || String(e) };  const resolved = await resolveApiBase();

  }  const headers: Record<string, string> = {

}    "Content-Type": "application/json",

  };

function normalizeDetections(detections: any[]): Detection[] {  if (resolved.authHeader) headers["Authorization"] = resolved.authHeader;

  if (!Array.isArray(detections)) return [];

  return detections.map((det: any) => {  const response = await fetch(`${resolved.base}/detect-batch`, {

    const className = det.class || det.className || det.label || det.name || "Unknown";    method: "POST",

    const confidence = det.confidence || det.score || det.probability || 0;    headers,

    let bbox = { x: 0, y: 0, width: 0, height: 0 };    body: JSON.stringify({ images }),

    if (det.bbox) {  });

      if (det.bbox.width !== undefined) {

        bbox = { x: det.bbox.x || 0, y: det.bbox.y || 0, width: det.bbox.width || 0, height: det.bbox.height || 0 };  if (!response.ok) {

      } else if (det.bbox.x2 !== undefined) {    const errData = await response

        bbox = { x: det.bbox.x1 || det.bbox.x || 0, y: det.bbox.y1 || det.bbox.y || 0, width: (det.bbox.x2 - (det.bbox.x1 || det.bbox.x || 0)) || 0, height: (det.bbox.y2 - (det.bbox.y1 || det.bbox.y || 0)) || 0 };      .json()

      }      .catch(() => ({ error: response.statusText }));

    } else if (det.box) {    throw new Error(

      bbox = { x: det.box.x || 0, y: det.box.y || 0, width: det.box.width || 0, height: det.box.height || 0 };      errData.error || `Batch detection failed: ${response.statusText}`

    } else if (det.bounding_box) {    );

      bbox = { x: det.bounding_box.x || 0, y: det.bounding_box.y || 0, width: det.bounding_box.width || 0, height: det.bounding_box.height || 0 };  }

    } else if (det.x !== undefined && det.y !== undefined) {  const data = await response.json();

      bbox = { x: det.x - (det.width / 2) || 0, y: det.y - (det.height / 2) || 0, width: det.width || 0, height: det.height || 0 };  if (!data.success) throw new Error(data.error || "Batch detection failed");

    } else if (Array.isArray(det.coordinates)) {  return data.results.map((r: any) =>

      const [x1, y1, x2, y2] = det.coordinates;    r.success ? normalizeDetections(r.detections || []) : []

      bbox = { x: x1, y: y1, width: x2 - x1, height: y2 - y1 };  );

    }}

    return { className, confidence, bbox };

  });export async function testModelConnection(): Promise<{

}  success: boolean;
  message: string;
}> {
  try {
    const testImage =
      "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8DwHwAFBQIAX8jx0gAAAABJRU5ErkJggg==";
    await detectObjects(testImage);
    return { success: true, message: "Model connection successful!" };
  } catch (e: any) {
    return { success: false, message: e?.message || String(e) };
  }
}

function normalizeDetections(detections: any[]): Detection[] {
  if (!Array.isArray(detections)) return [];
  return detections.map((det: any) => {
    const className =
      det.class || det.className || det.label || det.name || "Unknown";
    const confidence = det.confidence || det.score || det.probability || 0;
    let bbox = { x: 0, y: 0, width: 0, height: 0 };
    if (det.bbox) {
      if (det.bbox.width !== undefined) {
        bbox = {
          x: det.bbox.x || 0,
          y: det.bbox.y || 0,
          width: det.bbox.width || 0,
          height: det.bbox.height || 0,
        };
      } else if (det.bbox.x2 !== undefined) {
        bbox = {
          x: det.bbox.x1 || det.bbox.x || 0,
          y: det.bbox.y1 || det.bbox.y || 0,
          width: det.bbox.x2 - (det.bbox.x1 || det.bbox.x || 0) || 0,
          height: det.bbox.y2 - (det.bbox.y1 || det.bbox.y || 0) || 0,
        };
      }
    } else if (det.box) {
      bbox = {
        x: det.box.x || 0,
        y: det.box.y || 0,
        width: det.box.width || 0,
        height: det.box.height || 0,
      };
    } else if (det.bounding_box) {
      bbox = {
        x: det.bounding_box.x || 0,
        y: det.bounding_box.y || 0,
        width: det.bounding_box.width || 0,
        height: det.bounding_box.height || 0,
      };
    } else if (det.x !== undefined && det.y !== undefined) {
      bbox = {
        x: det.x - det.width / 2 || 0,
        y: det.y - det.height / 2 || 0,
        width: det.width || 0,
        height: det.height || 0,
      };
    } else if (Array.isArray(det.coordinates)) {
      const [x1, y1, x2, y2] = det.coordinates;
      bbox = { x: x1, y: y1, width: x2 - x1, height: y2 - y1 };
    }
    return { className, confidence, bbox };
  });
}
